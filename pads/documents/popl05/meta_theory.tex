\section{Meta-theory}
\label{sec:meta-theory}

\cut{This paragraph belongs somewhere in the TR:
A few things to note regarding variable names. First, all variable
names introduced in translation are by definition not equal to the
target of the substitution, nor present in the free variables of the
term being substituted. Second, for those types with bound variables,
we note that the potential alpha-conversion when performing a
substitution on the type exactly parallels any alpha-conversion of the
same variable where it appears in the translation of the type. Last,
all constructors, support functions and base-type parsers are closed
with respect to user-defined variable names.}

One of the most difficult, and perhaps most interesting, challenges of our
work on \ddc{} was determining what
properties we wanted to hold. What are the ``correct''
invariants of data description languages? While there are many
well-known desirable invariants for programming languages, the
meta-theory of data description languages has been
uncharted.

We present the following two properties as critical invariants of
our theory. We feel that they should hold, in some form, for any data
description language.
\begin{itemize}
\trversion{
\item {\bf Translation Completeness}: The semantic function
  $\trans[\cdot,,]$ is a total function of well-formed \ddc{} types.
}
\item {\bf Parser Type Correctness}: For a \ddc{}-type $\ty$, the
  representation and PD output by the parsing function of $\ty$ will
  have the types specified by $\itsem[\ty]$ and
  $\itpdsem[\ty]$, respectively.
  
\item {\bf Parser Error Correlation}: For any representation and PD output by a
  parsing function, the errors reported in the PD
  will be correlated with the errors present in the representation.
\end{itemize}

\trversion{
Before presenting the formal statement of these properties, we specify
some assumptions that we make about \ddc{} base types, their kinds,
types, and implementations, that are necessary for the satisfaction of
these properties. In essence, we assume that the properties we desire of
the rest of the calculus hold for the base types.
}
In the following formalization of these properties, we assume that \ddc{} base types, their kinds, representation and parse descriptor types, and parsers satisfy the properties we desire to hold of the rest of the calculus.  A formal statement of these assumptions appears in \appref{app:meta-theory}.

\trversion{
\begin{theorem}[Translation Completeness]
\label{thm:translation-completeness}
  If \ $\ddck[\ty,,\kind,\mcon]$ then $\trans[\ty,,] = e$.
\end{theorem}

\begin{proof}
  By induction on kinding derivations. For constant case, use the
  first item of Condition~\ref{cond:base-types}.
\end{proof}
}
\trversion{
We continue by stating and proving that parsers are type correct.
However, to do so, we must first establish some typing properties of the Rep
and PD constructors, as at least one of them appears in most
parsing functions. 

% Many of the constructor functions are polymorphic. However, those
% that take one or more parse descriptors often need to examine the
% headers of those PDs. Therefore, they are restricted to operate on
% value with a header. Such values most have a type that satisfies the
% ``has header''predicate defined below.

% \begin{definition}[Has PD Header Predicate]
%   \label{def:ispd}
%   $\ispdty  \ity$ iff $\ity = \ipty {\ity'}$ or $\ity = \imu \ityvar
%   {\ity'}$ and $\ispdty {\ity'}$.
% \end{definition}

% With this definitione we now state and prove that each constructor
% produces a value whose type corresponds to its namesake \ddc{} type.

% \begin{lemma}[Types of Constructors]
% \label{lem:types-of-constructors}
% \begin{itemize}
% \item $\newrepf {true} : \iarrow \iunitty \iunitty$
% \item $\newpdf  {true} : \iarrow \ioffty {\ipty \iunitty}$
% \item $\newrepf {false} : \iarrow \iunitty \invty$
% \item $\newpdf  {false} : \iarrow \ioffty {\ipty \iunitty}$
% \item $\newrepf {\gS} : \forall \ga,\gb.\iarrow {\iprod \ga \gb} {\iprod \ga \gb}$
% \item $\forall \pdtyvars \ga \gb.\newpdf {\gS} : 
%   \iarrow {\iprod \ga \gb}
%   {\ipty {(\ga \iprodi \gb)}}
% $
% \item $\newrepf {+left} : \forall \ga,\gb.\iarrow \ga 
%                             {\isum \ga \gb}$
% \item $\newrepf {+right} : \forall \ga,\gb.\iarrow \gb {\isum \ga \gb}$
% \item $\forall \pdtyvars \ga \gb.\newpdf {+left} : \iarrow \ga 
%                             {\ipty {(\isum \ga\gb)}}$
% \item $\forall \pdtyvars \ga \gb.\newpdf {+right} : \iarrow \gb 
%                             {\ipty {(\isum \ga \gb)}}$
% \item $\newrepf {\&} : \forall \ga,\gb.\iarrow {\iprod \ga \gb} {\iprod \ga \gb}$
% \item $\forall \pdtyvars \ga \gb.\newpdf {\&} : 
%    \ga \iprodi
%    \gb \iarrowi 
%          {\ipty {( \ga \iprodi  \gb)}}
% $.
% \item $\newrepf {set} : \forall \ga.\iprod \iboolty \ga 
%   \iarrowi {\isum \ga {\ierrty \ga}}$
% \item $\forall \pdtyvar \ga.\newpdf {set} : \iprod \iboolty \iarrow \ga {\ipty \ga}$
% \item $\newrepf {seq\_init} : \forall \ga.\iarrow \iunitty {\iintty \iprodi \iseq \ga}$
% \item $\forall \pdtyvar \ga.\newpdf {seq\_init} : \iarrow \ioffty {\iapty {\ga}}$
% \item $\newrepf {seq} : \forall \ga.\iarrow
%   {(\iintty \iprodi \iseq \ga) \iprodi \ga}
%   {\iintty \iprodi \iseq \ga}$
% \item $\forall \pdtyvars {\ga_{elt}} {\ga_{sep}}.\newpdf {seq} : 
%   (\iapty { {\ga_{elt}}}) \iprodi
%    {\ga_{sep}} \iprodi 
%    {\ga_{elt}} \iarrowi \\
%   \iapty { {\ga_{elt}}}$
% \item $\newrepf {compute} : \forall \ga.\iarrow \ga \ga$
% \item $\newpdf {compute} : \iarrow \ioffty {\ipty \iunitty}$
% \item $\newrepf {absorb} : \forall \pdtyvar \ga.\iarrow \ga {\isum
%     \iunitty \invty}$
% \item $\forall \pdtyvar \ga.\newpdf {absorb} : \iarrow \ga {\ipty
%     \iunitty}$
% \item $\newrepf {scan} : \forall \ga.\iarrow \ga {\isum \ga \invty}$
% \item $\forall \pdtyvar \ga.\newpdf {scan} : \iarrow {\iprod \iintty \ga}
%   {\ipty {(\isum {\iprod \iintty \ga} \iunitty)}}$
% \item $\newrepf {scan\_err} : \forall \ga.\iarrow \iunitty {\isum \ga \invty}$
% \item $\newpdf {scan\_err} : \forall \ga.\iarrow \ioffty
%   {\ipty {(\isum {\iprod \iintty \ga} \iunitty)}}$
% \end{itemize}  
% \end{lemma}

% \begin{proofsketch}
%   By inspection of code.
% \end{proofsketch}

With this lemma we now formally state that each constructor
produces a value whose type corresponds to its namesake \ddc{} type.
Note that all universally quantified \ddc{} types $\ty$ are assumed
to be well formed.

\begin{lemma}[Types of Constructors]
\label{lem:nice-types-of-constructors}
\begin{itemize}
\item $\newrepf {true} : \iarrow \iunitty \itsem[\ptrue]$
\item $\newpdf  {true} : \iarrow \ioffty {\itpdsem[\ptrue]}$
\item $\newrepf {false} : \iarrow \iunitty {\itsem[\pfalse]} $
\item $\newpdf  {false} : \iarrow \ioffty {\itpdsem[\pfalse]}$
\item $\forall \ty_1,\ty_2,x.\newrepf {\gS} : \iarrow {\iprod
    {\itsem[\ty_1]}{\itsem[\ty_2]}} {\itsem[\psig x {\ty_1}{\ty_2}]}$
\item $\forall \ty_1,\ty_2,x.\newpdf {\gS} : 
  \iarrow {\iprod {\itpdsem[\ty_1]}{\itpdsem[\ty_2]}}
  {\itpdsem[\psig x {\ty_1}{\ty_2}]}
$
\item $\forall \ty_1,\ty_2.\newrepf {+left} : \iarrow {\itsem[\ty_1]} 
                            {\itsem[\psum {\ty_1}{}{\ty_2}]}$
\item $\forall \ty_1,\ty_2.\newrepf {+right} : \iarrow {\itsem[\ty_2]} 
                            {\itsem[\psum {\ty_1}{}{\ty_2}]}$
\item $\forall \ty_1,\ty_2.\newpdf {+left} : \iarrow {\itpdsem[\ty_1]} 
                            {\itpdsem[\psum {\ty_1}{}{\ty_2}]}$
\item $\forall \ty_1,\ty_2.\newpdf {+right} : \iarrow {\itpdsem[\ty_2]} 
                            {\itpdsem[\psum {\ty_1}{}{\ty_2}]}$
\item $\forall \ty_1,\ty_2.\newrepf {\&} : \iarrow {\iprod
    {\itsem[\ty_1]}{\itsem[\ty_2]}} {\itsem[\pand {\ty_1}{\ty_2}]}$
\item $\forall \hdtvs {\ty_1}{\ty_2}.\newpdf {\&} : 
  \iarrow {\iprod {\itpdsem[\ty_1]}{\itpdsem[\ty_2]}}
  {\itpdsem[\pand {\ty_1}{\ty_2}]}$.
\item $\forall \ty,x,e.\newrepf {set} : \iprod \iboolty {\itsem[\ty]} 
  \iarrowi \itsem[\pset x \ty e]$
\item $\forall \ty,x,e.\newpdf {set} : \iprod \iboolty {\itpdsem[\ty]} 
  \iarrowi \itpdsem[\pset x \ty e]$
\item $\forall \ty,\ty_1.
  \newrepf {seq\_init} : \iarrow \iunitty {\itsem[\pseq \ty
      {\ty_1} {\_}]}$
\item $\forall \ty,\ty_1.
  \newpdf {seq\_init} : \iarrow \ioffty {\itpdsem[\pseq \ty
      {\ty_1} {\_}]}$
\item $\forall \ty,\ty_1.
  \newrepf {seq} : \iarrow {\itsem[\pseq \ty
      {\ty_1} {\_}] \iprodi \itsem[\ty]} 
  {\itsem[\pseq \ty
      {\ty_1} {\_}]}$
\item $\forall \ty,\ty_1.
  \newpdf {seq} : 
  \itpdsem[\pseq \ty {\ty_1} {\_}] \iprodi
   \itpdsem[\ty_1] \iprodi \itpdsem[\ty] \iarrowi \\
  \itpdsem[\pseq \ty {\ty_1} {\_}]$
% \item $\forall \ty,\ty_1,\ty_2,e.
%   \newrepf {seq\_init} : \iarrow \iunitty {\itsem[\pseq \ty
%       {\ty_1} {\pterm e {\ty_2}}]}$
% \item $\forall \ty,\ty_1,\ty_2,e.
%   \newpdf {seq\_init} : \iarrow \ioffty {\itpdsem[\pseq \ty
%       {\ty_1} {\pterm e {\ty_2}}]}$
% \item $\forall \ty,\ty_1,\ty_2,e.
%   \newrepf {seq} : \iarrow {\itsem[\pseq \ty
%       {\ty_1} {\pterm e {\ty_2}}] \iprodi \itsem[\ty]} 
%   {\itsem[\pseq \ty
%       {\ty_1} {\pterm e {\ty_2}}]}$
% \item $\forall \ty,\ty_1,\ty_2,e.
%   \newpdf {seq} : 
%   \itpdsem[\pseq \ty {\ty_1} {\pterm e {\ty_2}}] \iprodi
%    \itpdsem[\ty_1] \iprodi \itpdsem[\ty] \iarrowi \\
%   \itpdsem[\pseq \ty {\ty_1} {\pterm e {\ty_2}}]$
\item $\forall e.\newrepf {compute} : \forall \ga.\iarrow \ga {\itsem[\pcompute
    e \ga]}$
\item $\forall e.\newpdf {compute} : \forall \ga.\iarrow \ioffty
  {\itpdsem[\pcompute e \ga]}$
\item $\forall \ty.\newrepf {absorb} : \iarrow {\itpdsem[\ty]}
  {\itsem[\pabsorb \ty]}$
\item $\forall \ty.\newpdf {absorb} : \iarrow {\itpdsem[\ty]}
  {\itpdsem[\pabsorb \ty]}$
\item $\forall \ty.\newrepf {scan} : \itsem[\ty] \iarrowi
  \itsem[\pscan \ty]$
\item $\forall \ty.\newpdf {scan} : \iintty \iprodi \itpdsem[\ty] \iarrowi
  \itpdsem[\pscan \ty]$
\item $\forall \ty.\newpdf {scan} : \iintty \iprodi \itpdsem[\ty] \iarrowi
  \itpdsem[\pscan \ty]$
\item $\forall \ty.\newrepf {scan\_err} : \iunitty \iarrowi
  \itsem[\pscan \ty]$
\item $\forall \ty.\newpdf {scan\_err} : \ioffty \iarrowi
  \itpdsem[\pscan \ty]$
\end{itemize}  
\end{lemma}

\begin{proofsketch}
  By inspection of code. First we infer (by hand) the (polymorphic)
  type of each function. Then we verify that it matches the types
  specified above.
\end{proofsketch}
}

\begin{figure}
\small
\fbox{$\ptyc{\rctxt} = \ctxt$} 
    
\begin{align*}
  &\ptyc{\cdot} = \cdot \\
  &\ptyc{\rctxt,\ptyvar{=}\pmu \ptyvar \ty} = \ptyc \rctxt,\codefont{f_\ptyvar}{:}
  \kTrans[\kty,\asub \rctxt {\pmu \ptyvar \ty}]
\end{align*}  
  \caption{Recursive Parser \Implang{} Types}
  \label{fig:rec-parser-types}
\end{figure}

To prove our type correctness theorem by induction, we must account
for the fact that any free recursive type variables in
a \ddc{} type $\ty$ will become free function variables
in $\trans[\ty,,]$.  To that end, we define in \figref{fig:rec-parser-types}
the function $\ptyc \rctxt$, 
which maps recursive variable contexts
$\rctxt$ to typing contexts $\ctxt$. We also apply $\rctxt$ to $\ty$
to close any open references to recursive types before
determining the corresponding parser type. 
\trversion{  We don't explicitly require that $\ctxt$
be well formed in the premises, as it follows from the fact that $\ty$
is well formed in $\ctxt$.
}

\begin{theorem}[Type Correctness]
\label{thm:type-correctness}
  If  $\wfd \ctxt \rctxt$ and
   $\ddck[\ty,{\rctxt;\ctxt},\gk,\mcon]$ then
  $\stsem[{\trans[\ty,,]},{\ctxt,\ptyc \rctxt},
            {\kTrans[\kind,\asub \rctxt \ty]}]$.
\end{theorem}

\begin{proof}
  By induction on the height of the second derivation.
\end{proof}

\begin{corollary}[Type Correctness of Closed Types]
  If $\ddck[\ty,,\gk,\con]$ then
  $\stsem[{\trans[\ty,,]},,\kTrans[\kind,\ty]]$.  
\end{corollary}

We start our formalization of the error-correlation property by
defining the concept of representation and PD correlation.
Informally, a representation and a PD are correlated when the number
of errors recorded in the PD is at least as many as the number of
errors that appear in the representation and semantic errors, \ie{},
constraint violations, are properly reported.  Formally, we define
correlation with the relation $\corr \ty r p$. As the encoding of
errors in the representation and the meaning of error counts in the PD
are dependent on the \ddc{} type that produced them, correlation is
type directed.  However, some types, such as type application, are not
immediately useful in determining correlation, and must be normalized
before use. In \figref{fig:revised-ddc-syntax}, we define a set of
normalized types $\tyval$ and rules for normalizing the remaining
types. For clarity, we define $\corrkl \ty r p$ as a ``helper''
relation that normalizes types $\ty$ before checking for correlation.
The main correlation relation ($\corr \ty r p$), then, is defined only
for normalized types of base kind. Type abstractions are excluded as
they cannot directly produce representations and PDs.

\begin{figure}
\small
\begin{bnf}
%   \name{Kinds} \meta{\gk} \::= \kty \| \ity \-> \gk 
%                                \pext{\| \gk \-> \gk} \\
  \mname{Normalized\\ Types}{2} \meta{\tyval} \::= 
    \ptrue\| \pfalse \| \pbase{e} \| \plam{\var}{\ity}{\ty} \|
%  \nlnalt{Types}
%%        \|
%%       \pext{\plam{\ptyvar}{\gk}{\ty} \| \papp{\ty}{\ty} \nlalt}
%%       \pxpd{\ty}{e}
%%       \pext{\nlalt
%%         \ptransform{e}{e}{\ty} \| 
%%       }
    \psig x \ty \ty \| \psum \ty e \ty \nlalt
    \pand \ty \ty \|
    \pset x \ty e \|
    \pseq \ty \ty {\pterm e \ty} \nlalt
    \pcompute e \ity \| \pabsorb \ty \| \pscan{\ty} 
    \\
  \name{Types} \meta{\ty} \::= \tyval \| \papp{\ty}{e} \|
    \ptyvar \| \pmu{\ptyvar}{\ty} 
\end{bnf}  
\[
  \infer{
    \papp {\ty} {e} \stepsto \papp {\ty'} {e}
  }{
    \ty \stepsto \ty'
  }
\quad
  \infer{
    \papp {\tyval} {e} \stepsto \papp {\tyval} {e'}
  }{
    e \stepsto e'
  }
\quad
  \infer{
    \papp {(\plam x {} \ty)} {v} \stepsto \ty[v/x]
  }{}
\quad
  \infer{
    \pmu \ptyvar \ty \stepsto \ty[\pmu \ptyvar \ty/\ptyvar]
  }{}
\]
  \caption{\ddc{} Normalized Syntax and Normalization Rules}
  \label{fig:ddc-reduction-rules}
  \label{fig:revised-ddc-syntax}
\end{figure}

\begin{definition}
$\corrkl \ty r p$ iff if $\ty \kstepsto \tyval$ then $\corr \tyval r p$.
\end{definition}

In the following definition, we abbreviate $p.h.{nerr}$ as $p.{nerr}$.
and use $\mathtt{pos}$ to denote the function which returns zero when
passed zero and one otherwise.


\begin{definition}[Representation and PD Correlation Relation]
$\corr \ty r p$ iff exactly one of the following is true:
  \begin{itemize}
  \item $\ty = \ptrue$ and $r = \iuval$ and $p.{nerr} = 0$.
  \item $\ty = \pfalse$ and $r = \ierr$ and $p.{nerr} = 1$.
  \item $\ty = \pbase{e}$ and $r = \iinld \ity \const$ and $p.{nerr} = 0$.
  \item $\ty = \pbase{e}$ and $r = \iinrd \ity \ierr$ and $p.{nerr} = 1$.
  \item $\ty = \psig x {\ty_1} {\ty_2}$ and $r =\ipair {r_1} {r_2}$ and $p =
    \ipair h {\ipair {p_1} {p_2}}$ 
    and $h.{nerr} = \mathtt{pos}(p_1.{nerr}) + \mathtt{pos}(p_2.{nerr})$, $\corrkl
    {\ty_1} {r_1} {p_1}$ and $\corrkl {\ty_2[(r,p)/x]} {r_2} {p_2}$.
  \item $\ty = \psum {\ty_1} e {\ty_2}$ and $r =\iinld {\ity}{r'}$
    and $p = \ipair h {\iinld {\ity}{p'}}$
    and $h.{nerr} = \mathtt{pos}(p'.{nerr})$ and $\corrkl
    {\ty_1} {r'} {p'}$.
  \item $\ty = \psum {\ty_1} e {\ty_2}$ and $r =\iinr {r'}$
    and $p = \ipair h {\iinr {p'}}$
    and $h.{nerr} = \mathtt{pos}(p'.{nerr})$ and $\corrkl
    {\ty_2} {r'} {p'}$.
  \item $\ty = \pand {\ty_1} {\ty_2}$, $r = \ipair {r_1} {r_2}$ and $p =
    \ipair h {\ipair {p_1}{p_2}}$, 
    and $h.{nerr} = \mathtt{pos}(p_1.{nerr}) + \mathtt{pos}(p_2.{nerr})$, 
    $\corrkl {\ty_1} {r_1} {p_1}$ and $\corrkl {\ty_2} {r_2} {p_2}$.
  \item $\ty = \pset x {\ty'} e$, $r = \iinld \ity {r'}$ and $p =
    \ipair h {p'}$, 
    and $h.{nerr} = \mathtt{pos}(p'.{nerr})$, $\corrkl {\ty'}{r'}{p'}$
    and $e[(r',p')/x] \kstepsto\itrue$.
  \item $\ty = \pset x {\ty'} e$, $r = \iinrd \ity {r'}$
    and $p = \ipair h {p'}$,
    and $h.{nerr} = 1 + \mathtt{pos}(p'.{nerr})$,
    $\corrkl {\ty'}{r'}{p'}$ and $e[(r',p')/x] \kstepsto \ifalse$.
  \item $\ty = \pseq {\ty_e}{\ty_s}{\pterm {e,\ty_t}}$, 
    $r = \ipair {len} {\iarr{\vec {r_i}}}$, $p = \itup{h,\itup{{neerr},{len}',\iarr {\vec {p_i}}}}$,
    ${len} = {len}'$, ${neerr} = \sum_{i=1}^{len}
    \mathtt{pos}(p_i.{nerr})$, $\corrkl {\ty_e}
    {r_i} {p_i}$, (for $i=1 \ldots {len}$), and
    $h.{nerr} \geq \mathtt{pos}({neerr})$.
%   \item $\ty = \pmu \ptyvar {\ty'}$ and 
%     $\corrkl {\ty'[\pmu \ptyvar {\ty'}/\ptyvar]} r p$.
  \item $\ty = \pcompute e \ity$ and $p.{nerr} = 0$.
  \item $\ty = \pabsorb {\ty'}$, $r = \iinl \iuval$, and $p.nerr = 0$.
  \item $\ty = \pabsorb {\ty'}$, $r = \iinr \ierr$, and $p.nerr > 0$.
  \item $\ty = \pscan {\ty'}$, $r =\iinl {r'}$,
      $p = \ipair h {\iinl {\ipair i {p'}}}$,
      $h.nerr = \mathtt{pos}(i) + \mathtt{pos}(p'.nerr)$, and
      $\corrkl {\ty'}{r'}{p'}$.
  \item $\ty = \pscan {\ty'}$,
      $r =\iinr \ierr$,
      $p = \ipair h {\iinr \iuval}$, and
      $h.{nerr} = 1$.
  \end{itemize}
\end{definition}

\trversion{
Once again, we first need to prove error correllation properties of
the Rep and PD constructors, as expressed in the following lemma.

\begin{lemma}[Correllation Properties of Constructors]
  \label{lem:cons-props}
  \begin{itemize}
  \item $\corr \ptrue {\newrep {true} {}} {\newpd {true} \off}$.
  \item $\corr \pfalse {\newrep {false} {}} {\newpd {false} \off}$.
  \item If $\corrkl {\ty_1} {r_1} {p_1}$ and $\corrkl {\ty_2[(r,p)/x]} {r_2} {p_2}$
    then\\ $\corr {\psig x {\ty_1} {\ty_2}}
    {\newrep {\gS} {r_1,r_2}}{\newpd {\gS} {p_1,p_2}}$.
  \item If $\corrkl \ty r p$ then $\corr {\psum \ty e {\ty'}} 
      {\newrep {+left} r} {\newpd {+left} p}$.
  \item If $\corrkl \ty r p$ then $\corr {\psum {\ty'} e \ty} 
      {\newrep {+right} r} {\newpd {+right} p}$.
  \item If $\corrkl {\ty_1} {r_1} {p_1}$ and $\corrkl {\ty_2} {r_2} {p_2}$
    then\\ $\corr {\pand {\ty_1} {\ty_2}}
    {\newrep {\&} {r_1,r_2}}{\newpd {\&} {p_1,p_2}}$.
  \item If $\corrkl \ty r p$ and $e[(r,p)/x] \kstepsto c$ then\\ $\corr {\pset x \ty e} 
    {\newrep {set} {c,r}} {\newpd {set} {c,p}}$
  \item $\corr {\pseq \ty {\ty_s}{\pterm e {\ty_t}}} 
    {\newrep {seq\_init} {}} {\newpd {seq\_init} \off}$.
  \item If $\corr {\pseq \ty {\ty_s} {\pterm e {\ty_t}}} r p$ and
    $\corrkl \ty {r'} {p'}$ then for any $p''$, $\corr {\pseq \ty {\ty_s}{\pterm e {\ty_t}}}
    {\newrep {seq} {r,r'}} {\newpd {seq} {p,p'',p'}}$.    
  \item $\corr {\pcompute e \ity} {\newrep {compute} {e}} {\newpd {compute} \off}$.
  \item $\corr {\pabsorb \ty} {\newrep {absorb} p} {\newpd {absorb} p}$.
  \item If $\corrkl {\ty} r p$ then $\corr {\pscan \ty} 
      {\newrep {scan} r} {\newpd {scan} {i,p}}$.
  \item $\corr {\pscan \ty} 
      {\newrep {scan\_err} {}} {\newpd {scan\_err} \off}$.
  \end{itemize}
\end{lemma}

\begin{proof}
  By inspection of code. 
\cut{
  \reminder{Fix the following or drop it: }
  Array case is most complicated, in particular proving the clause
  $h.{nerr} \geq \mathtt{pos}({neerr})$. To do so, you must prove that
  $H_{seq}$ maintains this invariant. The first case of the match is the
  hard one, as ${nerr}$ is 0 (if its $1$, then it must be greater than
  or equal to $\mathtt{pos}(n)$, for any $n$).  First, as $h.{nerr} =
  0$, so too must $neerr$. Next, note that in this first case,
  $h1.{nerr} = 0$. Now, the new value of ${neerr}$ is just the sum of
  the original ${neerr}$ and $\mathtt{pos}(h1.{nerr})$, that is, $0 +
  0$.}
\end{proof}
}

Definition~\ref{def:err-corr} specifies the exact property we require
of parsing functions. At base kind, we require that any representation and PD
returned by the parser must be correlated. At higher kind, we require
that the function preserve the property of error correlation. Hence,
the definition is a simple form of logical relation.
Lemma~\ref{lem:err-corr-at-T} states that any well-formed type of base
kind is error-correlated.

\begin{definition}[Error Correlation Relation]
\label{def:err-corr}
$\ecpred \ty \kind$ iff exactly one of the following is true:
  \begin{itemize}
  \item $\kind = \kty$ and if $\trans[\ty,,] \sapp \spair<B,\off> \kstepsto
  \spair<\off',r,p>$ then $\corrkl \ty r p$
  \item $\kind = \ity \iarrowi \kind'$ and if $\stsem[v,,\ity]$
    then $\ecpred {\ty \sapp v} {\kind'}$
  \end{itemize}
\end{definition}
¯
\begin{lemma}[Error Correlation at Base Kind]
\label{lem:err-corr-at-T}
If $\ddck[\ty,,\kty,\con]$ and $\trans[\ty,,] \sapp \spair<B,\off> \kstepsto
  \spair<\off',r,p>$ then $\corrkl \ty r p$.
\end{lemma}

\begin{proofsketch}
  By induction on the height of the second derivation.
\end{proofsketch}

\begin{theorem}[Error Correlation]
\label{thm:err-corr}
If $\ddck[\ty,,\kind,\con]$ then $\ecpred \ty \kind$.
\end{theorem}

\begin{proof}
  By induction on the size of the kind $\kind$. For $\kind = \kty$, we
  use Lemma~\ref{lem:err-corr-at-T}.
\end{proof}

\trversion{
We conclude this section with a useful property of correlated representations
and PDs. If the PD reports no errors, then there are no syntactic
errors in the representation data structure {\it at any level}. 
\trversion{We formally define
{\it clean} (error-free) values next, followed by the statement of the
property itself.}

\begin{definition}[Clean Value]
$\noerr v$ iff exactly one of the following is true:
\begin{itemize}
\item $v = c$ and $c \neq \ierr$.
\item $v = \ifun f x e$.
\item $v = \ipair {v_1} {v_2}$ and $\noerr {v_1}$ and $\noerr {v_2}$.
\item $v = \iinl {v'}$ and $\noerr {v'}$.
\item $v = \iinr {v'}$ and $\noerr {v'}$.
\item $v = \iarr{v_1 \cdots v_n}$ and $\noerr {v_i}$ for $i=1\ldots n$.
\end{itemize}
\end{definition}

\begin{lemma}
  If $\corrkl \ty r p$ and $p.h.nerr = 0$ then $\noerr r$.
\end{lemma}

\begin{proof}
  By induction on the structure of r.
\end{proof}
}

\begin{corollary}
  If $\corrkl \ty r p$ and $p.h.nerr = 0$ then there are no syntactic
  or semantic errors in the representation data structure $r$.
\end{corollary}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "semantics"
%%% End: 
